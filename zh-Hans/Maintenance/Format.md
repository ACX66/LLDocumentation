# 🎯 项目 C++ 代码编写标准

## 介绍

&emsp;&emsp;本文档描述了 `LiteLoaderBDS` 主项目（以下简称 **LL**）中使用的编写标准。LL 项目内的代码都应遵循此标准。对于其他基于 LL 编写的插件，并不作任何要求，但编写标准对于编写大规模的插件项目尤为重要。

&emsp;&emsp;请注意，某些外部库有会偏离编码标准。被引用的外部库应当尽量保持其原有形态，不做任何修改，尤其是格式修改。

&emsp;&emsp;这些指南的最终目标是提高我们公共源代码库的可读性和可维护性。

> 欢迎参与到 LL 的开发中来！

## 语言、库和 C++ 标准

&emsp;&emsp;LL 中绝大部分为 C++ 代码，因此在使用外部库时，请尽可能选择现代的、具有 C++ 面向对象接口的库，且非必要不暴露 C 风格代码。若无法避免引用 C 语言库，请进行封装。LL 目前采用 C++20 标准，并会随着 BDS 的标准更新，因此请确保：一、您所引用的库支持 C++20 标准；二、您贡献的代码并非在 C++20 中处于**被弃用但未移除**状态（如果您不知道您的代码是否处于该状态，请访问[cppreference.com](https://zh.cppreference.com)查询）。

&emsp;&emsp;凡是 C++ 标准库和本项目中引用的其他库已经实现的数据结构，不应重复自定义实现。使用容器的第一步是明确您自己的目的：您想要一个顺序容器，一个类似集合的容器，还是一个类似键值对的容器？选择容器时最重要的是您计划如何访问容器的算法属性。基于此，您应该使用：

- `map/unordered_map` - 如果您需要基于另一个值有效查找一个值，则使用类似 `map` 的容器。类似 `map` 的容器还支持有效的包含查询（键是否在 `map` 中）。类映射容器通常不支持有效的反向映射（值到键）。如果需要，请使用两张 `map` 。例如 `MC/Types.hpp` 内的 `BidirectionalUnorderedMap` 。一些类似 `map` 的容器还支持按排序顺序通过键进行有效迭代。 `map` 通常要慢于 `unordered_map` 。使用 `unordered_map` 时，您需要为键实现 std::hash 的模板特化，或者自定义哈希函数。用 `map` 时，您需要为键实现比较函数。需要注意的是，普通 `map` 的键具有唯一性，如果您需要许多相同的键，请使用类似 `multimap` 的容器。

- `set/unordered_set` - 如果您需要将一堆东西放入自动消除重复项的容器中，则可以使用类似 `set` 的容器。一些类似 `set` 的容器支持按排序顺序通过元素进行有效迭代。类似 `set` 的容器比顺序容器更昂贵。当然，此结构也有对应的 multi 版本。

- `vector` - 顺序容器提供了添加元素的最有效方法，并跟踪它们添加到其中的顺序。它们允许重复并支持有效的迭代，但不支持基于键的有效查找。类似的还有队列，在编写 BFS 等算法时，请尽量使用类似 `queue` 的容器。当需要储存多维数据时，使用一个 `vector` ，讲多维坐标变换到 1 维进行存储访问，通常比 `vector` 嵌套的速度快。除非您需要对内存进行精细操作，您不应当使用 C 风格数组存放顺序列表数据。此外，您不应当使用 `array` 数据结构，请使用 `vector` 。

- `string` - 字符串容器是用于字符或字节数组的专用顺序容器或引用结构。请不要暴露类 C 的 char* 接口。

## 代码格式

### 注释

&emsp;&emsp;注释对于可读性和可维护性很重要。注释应当为英文，并使用适当的大小写和标点符号。注释旨在描述代码试图做什么以及为什么，而不是在微观层面上它是如何做到的。但对于某些算法中的魔法常量，请在同一行内给出说明。

#### 单行注释

单行注释用于说明某个量的作用，或某一算法的原理，需符合以下风格要求。

1. 使用 `// Example comment` 形式，注意 `// ` 的空格；

2. 首字母必须大写；

3. 如果注释构成完整的句子，请加上句点，否则请不要加上句点；

4. 如果某一注释过长，请换行，并保证注释文字内容对齐；

5. 如果该单行注释是对多行代码的注释，请在这些代码前空行中写注释，并在注释前加一个空行。

示例如下：

```cpp

constexpr int MAGIC_NUMBER = 12; // The magic number

// This algorithm is used to process the two masks generated by the specific
// algorithm with the magic number. If the result is not zero, the function
// should immediately return false to prevent crash.
if (MAGIC_NUMBER ^ this->mask1 && this->mask2) {
  return false;
}

```

#### 文件注释

所有文件都应当有文件注释，需符合以下风格要求。

示例如下：

```cpp

/**
 * @file Utils/ConfigHelper.h
 *
 * @brief This file contains declarations of the ConfigHelper class.
 *
 */

```

#### 类注释

所有**类定义**都应当有类注释，需符合以下风格要求。

示例如下：

```cpp

/**
 * @brief The ConfigHelper class provides configuration interfaces.
 *
 * @par Usage:
 * @code
 * nlohmann::json config;
 * config["title"] = "Default Title";
 * LL::ConfigHelper config_helper();
 * config_helper.get(config);
 * @endcode
 */

```

#### 函数注释

导出的LLAPI函数必须在**函数定义**（即头文件中）前写符合以下风格要求的Doxygen注释，请格外注意空格的使用。请不要重复写注释。

1. 每一行都应当和函数首行对齐。

2. 第一行必须为 `/**` ，最后一行必须为 ` */` 。

3. 除第一行和最后一行外，每一行都应当以 ` * ` 开头，即使该行为空行。

4. 第二行必须为以 `@brief ` 开头的函数内容简介，且满足如下要求：

    * 首字母大写，末尾加上句点；

    * 第一个单词必须为动词的第一人称单数一般现在时形式；

    * 若发生换行，请保证介绍内容的对齐；

    * 函数内容简介部分后，必须有一个空行。


6. 函数内容简介部分后是函数参数和返回值部分，参数行以 `@param  ` （两个空格）开头，返回值行以 `@return ` （一个空格）开头，且满足以下要求：

    * 首字母大写，末尾不应当加上句号；

    * 首字母对齐，且保证与参数名间至少有两个空格；

    * 参数说明顺序和函数定义中一致，返回值说明位于末尾；

    * 非布尔量参数或返回值说明应当是一个名词短语；布尔量参数或返回值应当以 `True if` 开头，若有必要，可以在分号后写 `False if`，例如 `True if the result is good; false if the result is bad or no result` 。

7. 如果你的函数需要进一步说明或提供使用示例，请在函数参数和返回值部分后加一个空行，再在下一行书写；请保证所有文字均处于至少一个Doxygen标记作用范围内。


以下示例来自 `/LiteLoader/Header/LLAPI.h` ，请参考。

```cpp
/**
 * @brief Check whether LiteLoaderBDS is in debug mode.
 * 
 * @return bool  True if it is in debug mode
 */
LIAPI bool isDebugMode();

/**
 * @brief Register a plugin.
 * 
 * @param  name     The name of the plugin
 * @param  desc     The description of the plugin
 * @param  version  The version of the plugin(LL::Version)
 * @param  others   The other information of the plugin(key-value)
 * @return bool     True if the plugin is registered successfully
 * 
 * @note The implementation of this function must be in header file(because of `GetCurrentModule`)
 * @par Example:
 * @code
 * LL::registerPlugin("Test", "A test plugin", Version(0, 0, 1, Version::Dev), {{"Note","This is Note"}});
 * @endcode
 */
inline bool registerPlugin(std::string name, std::string desc, LL::Version version, std::map<std::string, std::string> others) {
    return ::RegisterPlugin(GetCurrentModule(), name, desc, version, others);
}
// (FROM LiteLoader/Header/LLAPI.h)
```

### 头文件

&emsp;&emsp;鉴于目前MSVC对 `module` 的支持并不完善，我们使用头文件而非 `module` 。请确保所有头文件的首行是

```cpp

#pragma once

```

&emsp;&emsp;以保证头文件不被重复编译。头文件内的函数尽量全部使用 `inline` 使得编译器在头文件循环引用时可以忽略多重定义，选取其中一个。除模板外，函数的定义尽量与实现分开。

### 文件结构

一般来说，添加文件时，均在 `/LiteLoader/Header/` （头文件）和 `/LiteLoader/Kernel/` （实现文件）中进行。以下 `/` 指的是这两个目录

文件可以分为三类，其对应文件分别位于 `/` ， `/MC` 和 `/Utils` ，请参照以下要求选择API添加位置。

文件添加于 `/MC` 当且仅当满足以下所有条件：
    * 文件中API是Minecraft原生类的拓展成员，或是Minecraft原生类型定义。

文件添加于 `/Utils` 当且仅当满足以下所有条件：
    * 文件不直接或简介引用 `/MC/` 下任何文件、`/Global.h` 和 `/GlobalServiceAPI.h`；
    * 文件可以被迁移到一个与Minecraft完全无关的程序上使用。

文件添加于 `/` 当且仅当满足以下所有条件：
    * 无法添加至 `/MC` 或 `/Utils` 。

若您为了实现一个功能使用了多个文件，请建立文件夹包含所有这些文件。

### 命名

命名时，请遵守以下风格要求：

* 文件和目录命名应遵循大驼峰命名法，例如 `ExampleFile.h` 和 `ExampleDirectory/` ；如果是类的实现或独立命名空间实现，请和类或独立命名空间同名。

* 类命名应遵循大驼峰命名法，例如 `ExampleClass` 。

* 函数命名采用小驼峰命名法，例如 `doSomething()` ；对于返回值不是布尔量的函数，请保证命名为动词短语；对于返回值是布尔量的函数，请保证命名对应的短句可以被否定，例如 `hasShield()` 。

* 对于不利于人类识别的定义方法请不要使用，例如在同一行定义某个类的变量与变量指针。

* 命名应当使用英文全称，除非是Wikipedia能查到的公认的缩写。

* 在每一个类中，实现文件和头文件应当有相同的方法和变量顺序，且满足以下要求：

    * 访问说明说作用域顺序首先是 `public:` ，然后是 `protected:` ，最后是 `private:` ；

    * 在每个访问说明符作用域内，需符合以下顺序：
        1. 类型定义，例如 `class` 、`struct` 和 `enum class`；
        1. 非静态成员常量；
        1. 非静态成员变量；
        1. 构造函数；
        1. 析构函数；
        1. 运算符重载；
        1. 非静态成员函数；
        1. 静态成员常量；
        1. 静态成员变量；
        1. 静态成员函数。

    * 满足以上要求后，请按照**忽略大小写的字典序**排序；

### 使用括号

&emsp;&emsp;小括号的使用，可以有效的帮助开发者分辨逻辑，运算语句的顺序，在进行不同层级的符号运算时，如位移的同时进行加减法，逻辑语句中加入取非运算，比较大小与加减乘除混合使用等情况时，应当适当的添加小括号增加代码可读性。

### 缩进

&emsp;&emsp;请使用**四个空格**为一个单元的缩进方式，请勿使用 tab 缩进。

### 警告

&emsp;&emsp;将编译器警告视为错误，而不是 `disable` ，除非它由外部库引起。这样有利于寻找代码中的隐含错误。
&emsp;&emsp;外部库造成的警告应当尽量在 cpp 文件内 disable ，对于头文件的警告，应当在开头将此警告设置为 disable ，末尾此警告设置为 default 。

```cpp

// In xxx.h
#pragma once

#pragma warning(disable : xxxx)

// Some code

#pragma warning(default : xxxx)

```

### 格式化

&emsp;&emsp;LL 内附带了 `.clang-format` 文件，请使用此文件对代码进行格式化，而不是自己自创一套新的格式化方案，任何不符合代码格式的提交都有可能被拒绝。

&emsp;&emsp;如果您有充足的理由对某部分代码块不进行格式化，那么请使用 `// clang-format off` 与 `// clang-format on` 局部关闭代码格式化。

### 其它

#### 可移植性

&emsp;&emsp;任何情况下，请考虑代码的可移植性，对于非必要的偏移，请不要使用。所有使用可能发生变化的偏移的部分都应当写有统一格式的注释：

```cpp
/*_CHANGEABLE_OFFSET_16_BDS_1_19_020_02*/
dAccess<int, 16>(this);
```

&emsp;&emsp;此处的 16 为偏移的数值，1_19_020 代表最后一次更改偏移的版本为 1.19.20.02 。每当 LL 进行 BDS 版本兼容升级时，应当对所有使用可能发生变化的偏移的代码部分进行测试。

#### 可读性

&emsp;&emsp;请 “ 几乎总是 ” 使用 `auto` ，包括一些简短的模板，也可以使用 C++17 以后的 `auto` 形式。

#### 小心不必要的副本auto

&emsp;&emsp;`auto`的便利性让人很容易忘记它的默认行为是复制。特别是在基于范围的 `for` 循环中，粗心的复制造成的代价十分高昂。除非您需要复制，否则请使用 `auto&` ，`auto*`

#### 减少不必要的 include

&emsp;&emsp;include 稍有不慎就会导致很多错误，请不要进行多余的 include 操作。

#### 不要编写全局命名空间函数

&emsp;&emsp;所有函数，都应当处于 LL 的命名空间内，命名空间采用全部小写的形式，除非太长，否则不采用蛇形命名。

#### 使用提前 return/continue 简化代码

```cpp
bool *Player::eat(ItemStack* item) {
    if ((!item->isTerminator()) && item->isFood() && this->isHungry()) {
        ... some long code ....
    }

  return false;
}
```

&emsp;&emsp;相较于上述代码，我们更推荐下面的。

```cpp
bool *Player::eat(ItemStack* item) {

    if (item->isTerminator() || (!item->isFood()) || (!this->isHungry())) {
        return false;
    }

    ... some long code ....
}
```

&emsp;&emsp;长代码放在 if 内，会使得可用缩进变小，并且过长的翻阅过程也会是您分不清大括号的嵌套。

&emsp;&emsp;编写代码时，请尽量试着减少缩进。

#### 无论如何，都要使用大括号

&emsp;&emsp;无论 if ，for ，while 等语句下面的代码有多么简短，都必须使用大括号包住。

#### 将操作拆分

&emsp;&emsp;使用宏定义或新增函数的方式，将冗长的代码块变成小单元，例如：

```cpp
bool *Player::canEat() {

  ... some code ....

    bool FoundFood = false;
    for (unsigned I = 0, E = BarList.size(); I != E; ++I){
        if (BarList[I]->isFood()) {
        FoundFood = true;
        break;
        }
    }

if (FoundFood) {
  ...
}

  ... some code ....

}
```

&emsp;&emsp;相较于上述代码，我们更推荐下面的。

```cpp

static bool containsFood(const std::vector<ItemStack*> &List) {
    for (unsigned I = 0, E = List.size(); I != E; ++I){
        if (List[I]->isFood()){
            return true;
        }
    }
  return false;
}

bool *Player::canEat() {

  ... some code ....

if (containsFood(BarList)) {
  ...
}

  ... some code ....

}

```

#### 善用匿名命名空间

&emsp;&emsp;如上面的 containsFood ，可能仅仅需要使用一次，那么请将其放入实现文件的匿名命名空间中，不应当将其暴露给外部。

#### 不要使用 using namespace std

&emsp;&emsp;不要使用 using namespace std ，尤其是头文件内。

#### 不要end()每次都通过循环进行评估

&emsp;&emsp;在for不能使用基于范围的循环并且需要编写显式的基于迭代器的循环的情况下，请密切注意是否 end() 在每次循环迭代时重新评估。一个常见的错误是以这种风格编写循环：

```cpp
auto blocks = ...
for (auto I = blocks->begin(); I != blocks->end(); ++I){
    Level::setBlock(getPos(I),blocks[I]);
}

```

&emsp;&emsp;相较于上述代码，我们更推荐下面的。

```cpp
auto blocks = ...
for (auto I = blocks->begin(), E = blocks->end(); I != E; ++I){
    Level::setBlock(getPos(I),blocks[I]);
}
```

&emsp;&emsp;观察者可能很快指出这两个循环可能有不同的语义：如果容器正在发生增删，那么 `BB->end()` 可能会在每次循环中改变它的值，而第二个循环实际上可能不会是正确的。如果您确实依赖此行为，请以第一种形式编写循环并添加注释，表明您是故意这样做的。

&emsp;&emsp;为什么我们更喜欢第二种形式（正确时）？以第一种形式编写循环有两个问题。首先，它可能比在循环开始时评估它的效率低。在这种情况下，成本可能很小——每次循环都会增加一些额外的负载。但是，如果基础表达式更复杂，则成本会迅速上升。某些结束表达式实际上类似于：`SomeMap[X]->end()` 的循环。通过始终如一地以第二种形式编写它，您可以完全消除此问题，甚至不必考虑它。

&emsp;&emsp;第二个（甚至更大）的问题是，以第一种形式编写循环会向读者暗示循环正在改变容器（注释很容易证实这一事实！）。如果您以第二种形式编写循环，则无需查看循环体就可以立即看出容器没有被修改，这使得阅读代码和理解它的作用更容易。

#### 避免使用 std::endl

```cpp
std::cout << std::endl;
```

&emsp;&emsp;上述代码等价于以下代码。

```cpp
std::cout << '\n' << std::flush;
```

&emsp;&emsp;多数情况下，您可能并不需要刷新输出流，因此最好使用 '\n' 。

#### 首选 ++i

&emsp;&emsp;多数情况下，++i 要比 i++ 快很多。

#### 类型转换

&emsp;&emsp;不要使用 C 形式的类型转换，而是选用 static_cast<>() 之类的 C++ 类型转换形式。

## 代码审查

&emsp;&emsp;开发者在对 LL 进行维护时，不可擅自提交至 beta ，尤其是 main 仓库，应当以 pull request 的形式，先对代码进行编译确认代码无编译错误，并由至少 2 名开发者审查后，才可合并到 beta 分支。详情见[Commit格式](Commit.md)

## 单元测试

&emsp;&emsp;所有可能发生变化的偏移，在对应的 BDS 版本更新后，都应当对其进行单元测试，确保不会引发错误后才可上线。对于被内联掉的函数，应当尽量在头文件内进行复现并添加 inline 标识。切勿直接搬运 IDA 代码。在先前的版本进行单元测试确认原版实现与此实现结果完全一致后，才可上线。
